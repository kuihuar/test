package algorithm

import "fmt"

// 原理：相邻元素比较并交换，每轮将最大元素移至末尾。
// 复杂度：时间O(n²)，空间O(1)
func bubbleSort(arr []int) {
	n := len(arr)
	fmt.Printf("n: %+v\n", n)
	// 外层循环控制排序的轮数。因为每一轮排序都会将一个最大的元素“冒泡”到数组的末尾，
	// 所以最多需要 n - 1 轮排序就能将整个数组排好序。例如，对于长度为 5 的数组，最多进行 4 轮排序即可
	for i := 0; i < n-1; i++ {
		// 内层循环用于进行相邻元素的比较和交换。n - i - 1 是因为经过 i 轮排序后，
		// 已经有 i 个最大的元素被放到了数组的末尾，所以不需要再对这些元素进行比较，因此内层循环的范围会逐渐缩小
		for j := 0; j < n-i-1; j++ {
			fmt.Printf("j: %+v\tj+1: %+v\t arr[j]:%+v, arr[j+1]:%+v\n", j, j+1, arr[j], arr[j+1])
			if arr[j] > arr[j+1] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
			}
			// fmt.Printf("array: %+v\n", arr)
		}
		fmt.Printf("\tarray: %+v\n", arr)
	}
}

// 原理：逐个将元素插入已排序序列的正确位置。

// 复杂度：时间O(n²)，空间O(1)，适合小规模或部分有序数据。
// [5, 3, 4, 6, 2]

// 第一轮（i = 1）
// 初始状态：
// 已排序部分：[5]
// 未排序部分：[3, 4, 6, 2]
// key = arr[1] = 3
// j = i - 1 = 0
// 内层循环比较与移动：
// 比较 arr[j]（即 5）和 key（即 3），因为 5 > 3，所以将 5 向后移动一位，数组变为 [5, 5, 4, 6, 2]，然后 j 减 1 变为 -1。
// 此时内层循环条件 j >= 0 不满足，内层循环结束。
// 插入操作：
// 将 key（即 3）插入到 j + 1（即 0）的位置，数组变为 [3, 5, 4, 6, 2]。
// 第二轮（i = 2）
// 初始状态：
// 已排序部分：[3, 5]
// 未排序部分：[4, 6, 2]
// key = arr[2] = 4
// j = i - 1 = 1
// 内层循环比较与移动：
// 比较 arr[j]（即 5）和 key（即 4），因为 5 > 4，所以将 5 向后移动一位，数组变为 [3, 5, 5, 6, 2]，j 减 1 变为 0。
// 再比较 arr[j]（即 3）和 key（即 4），因为 3 < 4，内层循环条件 arr[j] > key 不满足，内层循环结束。
// 插入操作：
// 将 key（即 4）插入到 j + 1（即 1）的位置，数组变为 [3, 4, 5, 6, 2]。
// 第三轮（i = 3）
// 初始状态：
// 已排序部分：[3, 4, 5]
// 未排序部分：[6, 2]
// key = arr[3] = 6
// j = i - 1 = 2
// 内层循环比较与移动：
// 比较 arr[j]（即 5）和 key（即 6），因为 5 < 6，内层循环条件 arr[j] > key 不满足，内层循环结束。
// 插入操作：
// 将 key（即 6）插入到 j + 1（即 3）的位置，数组保持 [3, 4, 5, 6, 2] 不变。
// 第四轮（i = 4）
// 初始状态：
// 已排序部分：[3, 4, 5, 6]
// 未排序部分：[2]
// key = arr[4] = 2
// j = i - 1 = 3
// 内层循环比较与移动：
// 比较 arr[j]（即 6）和 key（即 2），因为 6 > 2，所以将 6 向后移动一位，数组变为 [3, 4, 5, 6, 6]，j 减 1 变为 2。
// 比较 arr[j]（即 5）和 key（即 2），因为 5 > 2，所以将 5 向后移动一位，数组变为 [3, 4, 5, 5, 6]，j 减 1 变为 1。
// 比较 arr[j]（即 4）和 key（即 2），因为 4 > 2，所以将 4 向后移动一位，数组变为 [3, 4, 4, 5, 6]，j 减 1 变为 0。
// 比较 arr[j]（即 3）和 key（即 2），因为 3 > 2，所以将 3 向后移动一位，数组变为 [3, 3, 4, 5, 6]，j 减 1 变为 -1。
// 此时内层循环条件 j >= 0 不满足，内层循环结束。
// 插入操作：
// 将 key（即 2）插入到 j + 1（即 0）的位置，数组变为 [2, 3, 4, 5, 6]。

func insertionSort(arr []int) {
	// 获取数组的长度
	n := len(arr)
	// 从数组的第二个元素开始遍历，因为第一个元素可以看作已经排好序
	// 外层循环使用变量 i 来遍历数组，从索引 1 开始，这是因为我们把数组的第一个元素（索引为 0）当作初始的已排序部分。
	// 每一轮循环，i 指向当前要插入到已排序序列中的未排序元素。
	// 在第 i 轮循环时，数组中索引从 0 到 i - 1 的元素构成了已排序部分，而索引为 i 的元素是待插入的未排序元素。
	// 所以，已排序部分的最后一个元素的索引就是 i - 1，因此我们将 j 初始化为 i - 1。
	for i := 1; i < n; i++ {
		// 取出当前要插入的元素
		key := arr[i]
		// j 指向已排序部分的最后一个元素
		j := i - 1
		// 从已排序部分的最后一个元素开始向前比较，如果当前元素大于 key，则将其后移一位
		// 内层循环会从已排序部分的最后一个元素（索引为 j）开始，向前依次比较每个元素和待插入元素 key 的大小。如果 arr[j] 大于 key，
		// 就把 arr[j] 向后移动一位（即 arr[j+1] = arr[j]），然后将 j 减 1，继续比较前一个元素
		for ; j >= 0 && arr[j] > key; j-- {
			arr[j+1] = arr[j]
			// j--
			fmt.Printf("arrrrr11:%+v\ti:%d\tj:%d\tkey:%d\n", arr, i, j, key)
		}
		// 找到合适的位置后，将 key 插入到该位置
		arr[j+1] = key
		fmt.Printf("arrrrr22:%+v\n", arr)
	}

}

// 原理：每轮选择最小元素放到已排序末尾。
// 复杂度：时间O(n²)，空间O(1)。

// 选择排序（Selection Sort）是一种简单直观的排序算法。
// 它的基本思想是每一轮从待排序的数据元素中选出最小（或最大，取决于排序要求，这里是升序排序，所以选最小）的一个元素，存放在序列的起始位置，
// 然后再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。
// [64, 25, 12, 22, 11]

// 第一轮（i = 0）

// 初始假设 minIdx = 0（对应元素 64）。
// 内层循环从 j = 1 开始，比较 25 < 64，更新 minIdx = 1；继续比较 12 < 25，更新 minIdx = 2；22 > 12，minIdx 不变；11 < 12，更新 minIdx = 4。
// 交换 arr[0] 和 arr[4]，数组变为 [11, 25, 12, 22, 64]。
// 第二轮（i = 1）

// 假设 minIdx = 1（对应元素 25）。
// 内层循环从 j = 2 开始，比较 12 < 25，更新 minIdx = 2；22 > 12，minIdx 不变。
// 交换 arr[1] 和 arr[2]，数组变为 [11, 12, 25, 22, 64]。
// 第三轮（i = 2）

// 假设 minIdx = 2（对应元素 25）。
// 内层循环从 j = 3 开始，比较 22 < 25，更新 minIdx = 3。
// 交换 arr[2] 和 arr[3]，数组变为 [11, 12, 22, 25, 64]。
// 第四轮（i = 3）

// 假设 minIdx = 3（对应元素 25）。
// 内层循环从 j = 4 开始，64 > 25，minIdx 不变。
// 交换 arr[3] 和 arr[3]（相当于不交换），数组仍为 [11, 12, 22, 25, 64]。
// 经过四轮排序后，数组完成升序排序。
func selectionSort(arr []int) {
	// 步骤 1: 获取数组的长度
	n := len(arr)
	// 步骤 2: 外层循环控制排序的轮数
	// 因为最后一个元素在前面的元素都排好序后自然就处于正确的位置，所以只需要进行 n - 1 轮排序。每一轮排序都会将一个最小元素放到已排序部分的末尾
	for i := 0; i < n-1; i++ {
		// 步骤 3: 假设当前索引 i 对应的元素是最小元素，记录其索引
		// 在每一轮排序开始时，假设当前索引 i 对应的元素是未排序部分中的最小元素，将其索引 i 赋值给 minIdx。
		minIdx := i
		// 步骤 4: 内层循环用于在未排序部分中寻找最小元素的索引
		// 内层循环从 i + 1 开始，遍历未排序部分的所有元素。目的是在未排序部分中找到最小元素的索引 。
		for j := i + 1; j < n; j++ {
			if arr[j] < arr[minIdx] {
				// 步骤 6: 如果 arr[j] 更小，则更新最小元素的索引为 j
				// 在内层循环中，比较当前元素 arr[j] 和假设的最小元素 arr[minIdx] 的大小。
				// 如果 arr[j] 更小，则更新最小元素的索引为 j ，即 minIdx = j 。
				// 这样可以确保 minIdx 总是指向未排序部分中的最小元素的索引
				minIdx = j
			}
		}
		fmt.Printf("第%d轮前:arr:%+v,minIdx:%d \n", i, arr, minIdx)
		// 步骤 7: 将最小元素与当前索引 i 对应的元素交换位置
		arr[i], arr[minIdx] = arr[minIdx], arr[i]
		fmt.Printf("第%d轮后:arr:%+v,minIdx:%d \n", i, arr, minIdx)
		// 内层循环结束后，已经找到了未排序部分中的最小元素的索引 minIdx。
		// 将该最小元素与当前索引 i 对应的元素交换位置，这样就将最小元素放到了已排序部分的末尾。
	}
}

// 快速排序采用分治法策略，它的基本步骤是：

// 1. 选择基准元素：从数组中选择一个元素作为基准（pivot）。
// 2. 分区操作：将数组中的元素重新排列，使得所有小于基准的元素放在基准的左边，所有大于基准的元素放在基准的右边。这个过程称为分区（partition）。
// 3. 递归排序：对基准左右两边的子数组分别递归地进行快速排序。

// 原理：分治法，选基准分割数组，递归排序子数组。

// 复杂度：平均时间O(n log n)，最坏O(n²)，空间O(log n)。
// 快速排序的基本思想
// 快速排序的核心思想是通过选择一个基准元素（pivot），将数组分为两部分，使得左边部分的所有元素都小于等于基准元素，
// 右边部分的所有元素都大于等于基准元素，然后分别对左右两部分递归地进行快速排序，最终使整个数组有序。
// arr：待排序的数组。
// low：当前待排序子数组的起始索引。
// high：当前待排序子数组的结束索引。

// 递归终止条件：当 low 大于等于 high 时，说明子数组中只有一个元素或者为空，无需排序，直接返回。
// 分区操作：调用 partition 函数，将数组 arr 从索引 low 到 high 进行分区，得到基准元素的最终位置 pi。
// 递归排序：对基准元素左边的子数组（索引从 low 到 pi - 1）和右边的子数组（索引从 pi + 1 到 high）分别递归调用 quickSort 函数进行排序。
var step int = 0

func quickSort(arr []int, low, high int) {
	step++
	fmt.Println()
	fmt.Printf("quickSort step=%+v arr=%+v, low=%+v, high=%+v\n", step, arr, low, high)
	if low < high {
		pi := partition(arr, low, high)
		fmt.Println("pi=", pi, "arr[pi]=", arr[pi])
		fmt.Println("quickSort(arr, low, pi-1)", "low=", low, "pi-1=", pi-1)
		quickSort(arr, low, pi-1)
		fmt.Println("quickSort(arr, pi+1, high)", "pi+1=", pi+1, "high=", high)
		quickSort(arr, pi+1, high)
	}
}

// 对数组 arr 中从索引 low 到 high 的元素进行分区操作，将基准元素放到其最终的正确位置，并返回该位置的索引。
// arr：待分区的数组。
// low：当前待分区子数组的起始索引。
// high：当前待分区子数组的结束索引。
// 逻辑：
// 选择基准元素：选择数组的最后一个元素 arr[high] 作为基准元素 pivot。
// 初始化索引 i：i 用于记录小于基准元素的元素的边界，初始值为 low - 1。
// 遍历数组：从索引 low 到 high - 1 遍历数组，对于每个元素 arr[j]：
// 如果 arr[j] 小于基准元素 pivot，则将 i 加 1，并交换 arr[i] 和 arr[j] 的位置。这样可以确保 arr[low] 到 arr[i] 之间的元素都小于基准元素。
// 放置基准元素：遍历结束后，将基准元素 arr[high] 与 arr[i + 1] 交换位置，使得基准元素左边的元素都小于它，右边的元素都大于等于它。
// 返回基准元素的最终位置：返回 i + 1，即基准元素的最终索引。

// [9, 5, 7, 1, 3, 8, 4, 6, 2]

// 第一次分区（调用 partition 函数）
// 选择基准元素：选择数组的最后一个元素 2 作为基准元素 pivot。
// 初始化索引 i：i = low - 1 = 0 - 1 = -1。
// arr:= []int{9, 5, 7, 1, 3, 8, 4, 6, 2}
// len(arr):9
// quickSort(arr,0, len(arr)-1)

func partition(arr []int, low, high int) int {

	fmt.Printf("-------before partition low=%+v, high=%+v, arr=%+v\n", low, high, arr)

	// 选择基准元素：pivot := arr[high]，选择当前子数组的最后一个元素作为基准元素
	pivot := arr[high]
	// 初始化索引 i：i := low - 1，i 用于记录小于基准元素的元素的最后一个位置
	// 初始时，将其设为 low - 1，因为还没有开始遍历数组，所以不存在小于基准元素的元素。
	i := low - 1
	// 使用变量 j 从 low 到 high - 1 遍历数组，依次检查每个元素与基准元素的大小关系
	for j := low; j < high; j++ {
		// 判断元素大小：如果当前元素 arr[j] 小于基准元素 pivot，说明这个元素应该放在基准元素的左边。
		if arr[j] < pivot {
			// 移动指针：将指针 i 向右移动一位，指向下一个可能放置小于基准元素的位置
			// 这样做是为了保证在后续的交换操作中，arr[i] 总是小于基准元素 pivot
			// 移动索引 i：将 i 的值加 1，表示小于基准元素的元素范围扩大了。
			i++
			// 交换元素：交换 arr[i] 和 arr[j] 的位置，使得小于基准元素的元素移动到了数组的左边。
			arr[i], arr[j] = arr[j], arr[i]
		}
	}
	// 最后，将基准元素 pivot 放到正确的位置上。放置基准元素
	// 为什么基础元素是 arr[high]？ 因为上面的循环结束后，j 已经遍历完了整个数组，
	arr[i+1], arr[high] = arr[high], arr[i+1]
	// 当遍历完除基准元素之外的所有元素后，将基准元素 arr[high] 与 arr[i + 1] 交换位置。
	// 此时，arr[i + 1] 位置的元素大于等于基准元素，交换后基准元素就处于正确的位置，
	// 即左边的元素都小于它，右边的元素都大于它。
	fmt.Printf("-------after partition pivot=%+v, arr[pivot]=%+v, arr=%+v\n", i+1, arr[i+1], arr)
	// fmt.Println()
	return i + 1
}

// 小于的放左边
func partition_less(arr []int, low, high int) int {
	pivot := arr[high]
	i := low - 1
	for j := low; j < high; j++ {
		if arr[j] <= pivot {
			i++
			arr[i], arr[j] = arr[j], arr[i]
		}
	}
	arr[i+1], arr[high] = arr[high], arr[i+1]
	return i + 1
}

// 大于的放右边
func partition_than(arr []int, low, high int) int {
	pivot := arr[low]
	i := high + 1
	for j := high; j > low; j-- {
		if arr[j] >= pivot {
			i--
			arr[i], arr[j] = arr[j], arr[i]
		}
	}
	arr[i-1], arr[low] = arr[low], arr[i-1]
	return i - 1
}

func partition_less_plus_than(arr []int, low, high int) int {
	// 选择第一个元素作为基准元素
	pivot := arr[low]
	left := low + 1
	right := high

	for true {
		// 从左向右找第一个大于基准的元素
		for left <= right && arr[left] <= pivot {
			left++
		}
		// 从右向左找第一个小于基准的元素
		for left <= right && arr[right] >= pivot {
			right--
		}
		// 如果 left 和 right 指针相遇或交叉，则退出循环
		if left > right {
			break
		}
		// 交换 left 和 right 位置的元素
		arr[left], arr[right] = arr[right], arr[left]
	}
	// 将基准元素放到正确的位置
	arr[low], arr[right] = arr[right], arr[low]
	return right
}

// 原理：分治法，递归分割数组后合并有序子数组。

// 复杂度：时间O(n log n)，空间O(n)。
// 间复杂度：归并排序的时间复杂度为O(nlogn)，其中 n 是数组的长度。这是因为每次将数组分割成两个子数组的时间复杂度为 O(logn)，
// 而合并两个子数组的时间复杂度为 O(n)。因此总的时间复杂度为 O(nlogn)。
// 空间复杂度：归并排序的空间复杂度为 O(n)，主要用于存储合并后的有序数组
// 它的基本思想是将一个数组分成两个子数组，分别对这两个子数组进行排序，然后将排好序的子数组合并成一个最终的有序数组
// Divide and Conquer
// 当传入的数组长度大于 1 时，会持续把数组从中间分成左右两个子数组，然后递归地对这两个子数组调用 mergeSort 函数。
// 不断重复分割操作，直到子数组长度为 1 或 0，此时子数组自然是有序的。
func mergeSort(arr []int) []int {
	// 当数组的长度小于等于 1 时，说明该数组已经是有序的（空数组或者只有一个元素的数组本身就是有序的）
	if len(arr) <= 1 {
		return arr
	}
	// 计算数组的中间位置 mid，将数组从中间分割成左右两个子数组
	mid := len(arr) / 2
	// 递归调用 mergeSort 函数对左右两个子数组分别进行排序。
	// arr[:mid] 表示从数组的起始位置到中间位置（不包含中间位置）的子数组，arr[mid:] 表示从中间位置到数组末尾的子数组
	left := mergeSort(arr[:mid])
	right := mergeSort(arr[mid:])
	// 调用 merge 函数将排好序的左右两个子数组合并成一个有序数组，并返回该数组
	return merge(left, right)
}

// 创建结果数组：result 数组用于存放合并后的有序元素，其容量为左右子数组长度之和。
// 比较与合并：利用两个指针 i 和 j 分别遍历左右子数组，比较当前指针所指元素的大小，将较小的元素添加到 result 数组中，然后移动相应的指针。
// 处理剩余元素：当其中一个子数组遍历完后，将另一个子数组剩余的元素直接添加到 result 数组末尾。
func merge(left, right []int) []int {
	result := make([]int, 0, len(left)+len(right))
	i, j := 0, 0

	for i < len(left) && j < len(right) {
		if left[i] < right[j] {
			result = append(result, left[i])
			i++
		} else {
			result = append(result, right[j])
			j++
		}
	}
	result = append(result, left[i:]...)
	result = append(result, right[j:]...)
	return result
}

// 原理：构建最大堆，交换堆顶与末尾元素，调整堆。

// 复杂度：时间O(n log n)，空间O(1)。

// 1. 利用堆的特性高效获取最大值
// 最大堆是一种完全二叉树结构，它的特点是每个节点的值都大于或等于其子节点的值。这意味着堆顶元素（根节点）始终是整个堆中的最大值。
// 利用这个特性，我们可以在 O(1) 的时间复杂度内获取到当前堆中的最大值。在排序过程中，我们需要不断找出未排序部分的最大值并将其放到合适的位置，最大堆正好可以高效地满足这个需求。

// 2. 便于后续调整堆结构
// 最大堆的结构使得在交换元素后，我们可以相对容易地通过调整操作（heapify）重新恢复堆的性质。
// 当我们把堆顶元素（最大值）拿走后，堆的结构可能被破坏，但由于堆的性质，我们可以通过简单的比较和交换操作，在 O(logn) 的时间复杂度内将剩余元素重新调整为最大堆，方便下一次继续获取最大值。

// 交换元素并调整堆的过程
// 1. 交换堆顶元素和堆的最后一个元素
// 在构建好最大堆后，堆顶元素是整个数组中的最大值。我们将堆顶元素与堆的最后一个元素交换位置。这样，最大值就被放到了数组的末尾，这个位置就是它在有序数组中的最终位置。

// 2. 调整剩余元素为最大堆
// 交换元素后，堆的性质可能被破坏，因为新的堆顶元素可能不满足最大堆的要求。
// 此时，我们对剩余的元素（不包括已经排好序的最后一个元素）调用 heapify 函数进行调整，使其重新成为最大堆。这个过程会将剩余元素中的最大值重新放到堆顶。

// 3. 重复上述步骤
// 不断重复交换堆顶元素和当前堆的最后一个元素，并调整剩余元素为最大堆的过程，每次都能将当前未排序部分的最大值放到合适的位置，直到整个数组都被排序。

func heapSort(arr []int) {
	n := len(arr)
	// 第一步：构建最大堆：
	// n 是数组的长度。
	// 从最后一个非叶子节点开始（即 n/2 - 1），依次向前调用 heapify 函数，将每个子树调整为最大堆。
	// 特点： 每个节点的值都大于或等于其子节点的值
	// 所以处理的是最后一个非叶子节点及其之后的所有节点，这些节点都是叶子节点或者只有一个子节点的节点，不需要再进行 heapify 操作。
	// 最后一个非叶子节点的索引是 n/2 - 1，因为对于一个完全二叉树，非叶子节点的索引范围是从 0 到 n/2 - 1。
	for i := n/2 - 1; i >= 0; i-- {
		fmt.Println("heapSort n:", n, "i:", i)
		heapify(arr, n, i)
	}
	fmt.Printf("heapSort finished arr: %+v\n", arr)
	// 第二步：交换元素并调整堆：
	// 将堆顶元素（最大值，即 arr[0]）与当前堆的最后一个元素（arr[i]）交换。
	// 交换后，堆的性质可能被破坏，因此需要调用 heapify 函数将剩余的元素（长度为 i）重新调整为最大堆。
	for i := n - 1; i > 0; i-- {
		arr[0], arr[i] = arr[i], arr[0]
		heapify(arr, i, 0)
	}
	fmt.Printf("heapSort optimized arr: %+v\n", arr)
}

func heapify(arr []int, n, i int) {
	fmt.Println("  heapify n:", n, "i:", i)
	// 1. 初始化最大值索引：
	largest := i
	// 2. 计算左右子节点的索引：
	left, right := 2*i+1, 2*i+2
	// 找到左子节点和右子节点中值最大的节点

	// 3. 比较左右子节点和当前节点的值：
	if left < n && arr[left] > arr[largest] {
		largest = left
	}
	if right < n && arr[right] > arr[largest] {
		largest = right
	}
	// 如果最大值不是当前节点，则交换并递归调整
	if largest != i {
		arr[i], arr[largest] = arr[largest], arr[i]
		heapify(arr, n, largest)
	}
}

// 原理：分组插入排序，逐渐缩小间隔。

// 复杂度：时间O(n log² n)，空间O(1)
// 希尔排序（Shell Sort）是插入排序的一种更高效的改进版本，也称为缩小增量排序。
// 它的基本思想是将原始数据分成多个子序列来进行插入排序，随着增量逐渐减小，子序列的长度逐渐增加，整个序列会变得越来越接近有序，
// 最后当增量为 1 时，就相当于进行一次普通的插入排序，但此时数据已经基本有序，插入排序的效率会大大提高。
// https://juejin.cn/post/6973862597737054244
func shellSort(arr []int) {
	// 1. 获取数组长度
	n := len(arr)
	fmt.Printf("shellSort length: %d\n", n)
	// 2. 外层循环：控制增量 gap
	// 初始化增量 gap 为数组长度的一半，这是希尔排序的初始增量设置。
	// 每次循环将 gap 除以 2，不断缩小增量，直到 gap 为 0 时停止循环
	for gap := n / 2; gap > 0; gap /= 2 {
		fmt.Printf("out loop gap:%d\n", gap)
		// 3. 中层循环：遍历每个子序列
		// 从第 gap 个元素开始遍历数组，对于每个元素，将其作为当前要插入的元素
		// 这里的 i 表示当前正在处理的元素的索引，从 gap 开始是因为要将数组分成多个子序列进行处理
		for i := gap; i < n; i++ {
			fmt.Printf("\t\tmiddle loop i: %d\n", i)
			// 4. 保存当前元素
			// 将当前要插入的元素 arr[i] 保存到临时变量 temp 中，方便后续移动元素时不会丢失该元素的值。
			temp := arr[i]
			// 初始化一个变量 j 并将其赋值为 i，用于后续在子序列中查找合适的插入位置。
			j := i
			// 5. 内层循环：在子序列中进行插入排序
			// 这个循环用于在当前子序列中找到合适的插入位置。
			// 条件 j >= gap && arr[j-gap] > temp
			// 表示只要 j 大于等于 gap 且 j 位置前 gap 个位置的元素大于当前要插入的元素 temp，就将 arr[j-gap] 元素后移 gap 个位置
			// j -= gap 表示每次将 j 向前移动 gap 个位置，继续比较。
			for ; j >= gap && arr[j-gap] > temp; j -= gap {
				arr[j] = arr[j-gap]
			}
			// 插入元素
			// 当内层循环结束时，说明已经找到了合适的插入位置 j，将之前保存的 temp 元素插入到 arr[j] 位置。
			arr[j] = temp
		}
	}
}

// 1. 复杂度分析：理解各算法的时间、空间复杂度及稳定性。
//
// 2. 适用场景：如插入排序适合小数据，归并排序适合链表排序，快速排序适合通用场景。
//
// 3. 优化策略：如快速排序的随机化pivot，归并排序的原地合并优化。

// 4. 语言特性：Golang中切片处理、递归实现注意事项。
func SortExample() {
	arr := []int{64, 34, 25, 12, 22, 11, 90}
	// arr = []int{9, 5, 7, 1, 3, 8, 4, 6, 2}
	// arr = []int{64, 34, 25, 12, 22, 11, 90, 9, 5, 7, 1, 3, 8, 4, 6, 2}
	fmt.Printf("array= %+v\n", arr)
	heapSort(arr)
	fmt.Printf("Sorted array=%+v\n", arr)
}
